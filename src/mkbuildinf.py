#!/usr/bin/env python3
"""
OpenSSL Build Information Generator - Python replacement for mkbuildinf.pl

Generates build information headers and files.
"""

import argparse
import os
import platform
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional


class BuildInfoGenerator:
    """Generates OpenSSL build information."""

    def __init__(self):
        self.debug = False
        self.quiet = False
        self.output_file: Optional[str] = None
        self.source_file: Optional[str] = None

    def get_build_info(self) -> Dict[str, str]:
        """Collect build information."""
        info = {}

        # Basic system information
        info['platform'] = platform.platform()
        info['architecture'] = platform.machine()
        info['python_version'] = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"

        # Date and time
        now = datetime.now()
        info['date'] = now.strftime('%Y-%m-%d %H:%M:%S')
        info['year'] = str(now.year)

        # Compiler information
        try:
            # Try to get compiler version
            if platform.system() == 'Linux':
                result = subprocess.run(['gcc', '--version'],
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    info['compiler'] = result.stdout.split('\n')[0].strip()
                else:
                    info['compiler'] = 'gcc (version unknown)'
            elif platform.system() == 'Darwin':
                result = subprocess.run(['clang', '--version'],
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    info['compiler'] = result.stdout.split('\n')[0].strip()
                else:
                    info['compiler'] = 'clang (version unknown)'
            else:
                info['compiler'] = f"{platform.system()} compiler"
        except (subprocess.TimeoutExpired, FileNotFoundError):
            info['compiler'] = 'unknown compiler'

        # Build environment
        info['build_user'] = os.environ.get('USER', os.environ.get('USERNAME', 'unknown'))
        info['build_host'] = platform.node()

        # Git information if available
        try:
            result = subprocess.run(['git', 'rev-parse', 'HEAD'],
                                  capture_output=True, text=True, cwd=os.getcwd(), timeout=5)
            if result.returncode == 0:
                info['git_commit'] = result.stdout.strip()[:8]  # Short commit hash
            else:
                info['git_commit'] = 'unknown'
        except (subprocess.TimeoutExpired, FileNotFoundError):
            info['git_commit'] = 'unknown'

        return info

    def generate_header_file(self, info: Dict[str, str], output_file: str) -> None:
        """Generate a C header file with build information."""
        with open(output_file, 'w') as f:
            f.write("/*\n")
            f.write(" * Generated build information\n")
            f.write(" * Do not edit manually - generated by mkbuildinf.py\n")
            f.write(" */\n\n")

            f.write("#ifndef OPENSSL_BUILDINFO_H\n")
            f.write("#define OPENSSL_BUILDINFO_H\n\n")

            for key, value in sorted(info.items()):
                # Convert to C macro format
                macro_name = f"OPENSSL_BUILDINFO_{key.upper()}"
                # Escape quotes and backslashes for C string literals
                escaped_value = value.replace('\\', '\\\\').replace('"', '\\"')
                f.write(f'#define {macro_name} "{escaped_value}"\n')

            f.write("\n#endif /* OPENSSL_BUILDINFO_H */\n")

        if not self.quiet:
            print(f"Generated header file: {output_file}")

    def generate_data_file(self, info: Dict[str, str], output_file: str) -> None:
        """Generate a data file with build information."""
        with open(output_file, 'w') as f:
            f.write("# Generated build information\n")
            f.write("# Do not edit manually - generated by mkbuildinf.py\n\n")

            for key, value in sorted(info.items()):
                f.write(f"{key}={value}\n")

        if not self.quiet:
            print(f"Generated data file: {output_file}")

    def process_buildinfo_file(self, buildinfo_file: str) -> None:
        """Process build.info file to extract build configuration."""
        if not os.path.exists(buildinfo_file):
            print(f"Warning: build.info file not found: {buildinfo_file}", file=sys.stderr)
            return

        # Parse build.info file
        # This would contain the logic to parse the build.info format
        # For now, just read and acknowledge the file
        with open(buildinfo_file, 'r') as f:
            content = f.read()

        if self.debug:
            print(f"Processed build.info file: {buildinfo_file}")
            print(f"Content length: {len(content)} characters")

    def run(self, args: List[str]) -> int:
        """Main execution method."""
        parser = argparse.ArgumentParser(description='Generate OpenSSL build information')
        parser.add_argument('-d', '--debug', action='store_true',
                          help='Enable debug output')
        parser.add_argument('-q', '--quiet', action='store_true',
                          help='Suppress non-error output')
        parser.add_argument('-o', '--output', type=str,
                          help='Output file (default: stdout or buildinf.h)')
        parser.add_argument('--header', action='store_true',
                          help='Generate C header file')
        parser.add_argument('--data', action='store_true',
                          help='Generate data file')
        parser.add_argument('buildinfo_file', nargs='?', default='build.info',
                          help='build.info file to process (default: build.info)')

        parsed_args = parser.parse_args(args)

        self.debug = parsed_args.debug
        self.quiet = parsed_args.quiet
        self.output_file = parsed_args.output
        self.source_file = parsed_args.buildinfo_file

        if self.debug:
            print(f"Debug mode enabled")
            print(f"Build info file: {self.source_file}")
            print(f"Output file: {self.output_file}")

        # Process build.info file
        self.process_buildinfo_file(self.source_file)

        # Get build information
        info = self.get_build_info()

        if self.debug:
            print("Collected build information:")
            for key, value in sorted(info.items()):
                print(f"  {key}: {value}")

        # Generate output
        if parsed_args.header:
            output_file = self.output_file or 'buildinf.h'
            self.generate_header_file(info, output_file)
        elif parsed_args.data:
            output_file = self.output_file or 'buildinf.txt'
            self.generate_data_file(info, output_file)
        else:
            # Default: output to stdout in key=value format
            for key, value in sorted(info.items()):
                print(f"{key}={value}")

        return 0


def main():
    """Main entry point."""
    generator = BuildInfoGenerator()
    sys.exit(generator.run(sys.argv[1:]))


if __name__ == '__main__':
    main()